## PCB**(Process Control Block)**

![image](https://github.com/sopt-makers/sopt-backend/assets/51692363/28c9f0f1-ae1e-4457-80cc-571c69f9cc2a)

자료구조 중 하나**(data structure)** Single 프로세스 또는 태스크를 관리하고 제어하기 위해 사용

- 운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스를 PCB
  1. 프로세스 식별자(Process ID)
  2. 프로세스 상태(Process State) : 생성(create), 준비(ready), 실행 (running), 대기(waiting), 완료(terminated) 상태가 존재.
  3. 프로그램 계수기(Program Counter) : 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킴.
  4. CPU 레지스터 및 일반 레지스터

  5. CPU 스케줄링 정보 : 우선 순위, 최종 실행시각, CPU 점유시간 등
  6. 메모리 관리 정보 : 해당 프로세스의 주소 공간 등
  7. 프로세스 계정 정보 : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  8. 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
  9. 포인터 : 부모프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등.

운영 체제의 메모리에 저장

- 운영 체제의 스케줄러에 의해 액세스되고 업데이트
- 어떤 프로세스가 실행되어야 하는지, 어떤 순서로 실행되어야 하는지를 결정
  - PCB의 정보를 사용하여 프로세스의 우선 순위, 프로세스가 실행된 기간, 프로세스가 차단되었는지 또는 입력 대기 중인지 여부를 결정
- PCB가 없으면 운영 체제는 여러 프로세스를 효과적으로 관리할 수 없고 충돌과 리소스 경합을 피하면서 필요한 리소스에 액세스

## context switching

레지스터 : PCB가 저장되는 공간

1. 실행 중인 프로세스의 상태를 저장 (PCB)
2. 다른 프로세스의 상태를 로드
3. 다른 프로세스가 중단된 시점부터 실행을 재개

- context switching 에서 context = 레지스터 값
- 말그대로 context(레지스터 = 해당 프로세스를 실행하기 위한 해당 프로세스의 정보)를 바꿈

### 왜 필요한가?

운영 체제는 프로세스나 스레드의 동시 실행을 지원하지만
코드 실행에 사용할 수 있는 CPU는 하나뿐이기 때문에 컨텍스트 전환이 필요

- Context Switching 때 해당 CPU는 아무런 일을 하지 못한다.
- 컨텍스트 스위칭이 잦아지면 오히려 오버헤드가 발생해 효율(성능)이 떨어진다.
- 컨텍스트 전환은 대량의 데이터를 저장 및 복원하고 시스템 구조를 업데이트하는 작업이기 때문에 시스템 리소스 및 오버헤드 측면에서 비용이 많이 드는 작업
