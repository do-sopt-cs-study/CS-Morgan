# Race Condition

두 개 이상의 프로세스가 공유 자원에 **동시에** 접근할 때, 실행 순서에 따라 **결과값이 다르게** 나오는 상태

### Race condition 예시

![image](https://github.com/do-sopt-cs-study/CS-Morgan/assets/51692363/953285a5-7369-4a24-a102-2a4513758059)

### Race condition 방지

이런 문제를 해결하기 위해서 상호배제 (mutual exclusion)을 지원한다.

- 세마포어, 뮤텍스, 원자성 명령어 같은 OS 수준에서 low한 구현 존재
- 응용 수준에서는 이러한 기능들이 모니터로 제공되므로 각자 환경에 맞게 적절한 것을 사용

## 교착상태

두 개 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

![image](https://github.com/do-sopt-cs-study/CS-Morgan/assets/51692363/a6acf3ca-5968-4142-880d-48443587e236)

### 교착상태의 필요충분조건

1. **상호배제** (Mutual Exclusion)

   : 자원은 한 시점에 하나의 프로세스만 접근할 수 있도록 보호된다.

2. **점유와 대기** (Hold and Wait)

   : 1개 이상의 자원을 점유한 상태에서 이미 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다.

3. **비선점** (Non-preemption)

   : 다른 프로세스가 점유한 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.

4. **환형 대기** (Circular Wait)

   : 대기하는 프로세스들이 원형을 이루며 서로에게 필요한 자원을 보유하고 있음.

# 교착상태 해결 방법

## 교착상태 예방 (Prevention)

필요충분조건 중 하나를 제거.

- 상호배제 제거 : OS가 동시성 제어를 위해 제공해야 하는 기능이므로 X
- 점유대기 제거 : 프로세스 시작 전 필요한 자원을 모아서 한번에 할당하거나 거부
  - 모든 자원이 할당되는 동안 프로세스들이 멈춘다 → 비효율
  - 짧은 시간 사용할 자원도 점유해야 한다 → 비효율
  - 동적으로 할당되는 자원을 미리 알기 어렵다.
- 비선점 제거 : 자원 점유 중인 프로세스는 다른 자원을 요구할 때 거부당하면 점유한 자원을 반납하고 다시 요청한다.
- 환형대기 제거 : 자원마다 고유 번호를 할당하고 각 프로세스는 한 방향으로만 자원을 요구할 수 있다. (방향을 고정시킨다)

예방 기법은 전반적으로 리소스 낭비가 심하다.

## 교착상태 회피 (Avoidance)

자원 할당 시점에 교착상태 **발생 가능성**이 있다면 **할당을 거부**한다.

### Safe State

교착상태를 발생시키지 않으면서 각 프로세스가 요구한 자원을 할당해줄 수 있는 상태

### Unsafe State

교착상태가 발생하기 위한 필요조건으로 반드시 발생하는 상태는 아니다.

### 은행원 알고리즘

자원 종류마다 자원이 여러 개 있을 때 사용할 수 있는 알고리즘.

1. 스레드가 시작할 때 각 스레드 최대 자원 개수를 자원 종류마다 미리 신고.
   - 이 숫자가 자원의 총 보유 수를 넘어서면 안 됨
2. 스레드가 자원들을 요청 → 시스템은 해당 요청을 수용했을 때 안전 상태인지 판단 - 계속 안전한 경우 → 그 요청을 들어줌 - 불안전한 경우 → 해당 요청은 허락이 되지 않은 채 다른 스레드가 끝날 때까지 대기
   ![image](https://github.com/do-sopt-cs-study/CS-Morgan/assets/51692363/afb7be4f-7f3f-4dca-8ea1-e86d2e24d8c8)
   쓰레드와 자원 상태

- 시스템에 5개의 프로세스가 있다고 가정
- A, B, C 세 가지 종류의 자원이 있다고 가정
  - A 자원의 개수 = 10개
  - B 자원의 개수 = 5개
  - C 자원의 개수 = 7개
- 시스템의 현재 상태는 아래의 표를 따름
  - Need의 행렬 값은 (Max - Allocation)으로 얻을 수 있다.
  - 해당 시스템은 안전하다.
    - <T1, T3, T4, T2, T0> 순서가 안전성 기준을 만족시키는 순열이 존재
- **해당 상태에서 T1이 A 자원 1개와 C 자원 2개를 추가로 요청한다고 가정**→ 즉, Request(1) = (1,0,2)

1. 먼저, `Request ≤ Available` 여부를 검사해야 함← Reqeust(1) = (1,0,2) 요청을 들어줄 것인지 판단하기 위해
2. (1,0,2) ≤ (3,3,2)인지 여부를 검사한다. → 해당 조건을 만족
3. 해당 요청을 들어주는 것처럼 상태 정보를 만들어봄
4. 해당 상태가 안전한지 확인하기 위해 안전성 알고리즘을 돌린다.→ <T1, T3, T4, T0, T2>가 안전성 조건을 만족시킴을 알 수 있다.
5. 안전성 조건을 만족시키기 때문에 T1의 요청을 즉시 들어준다.
6. 해당 상태에서 T4가 (3,3,0)을 요청→ 자원이 모자라므로 들어줄 수 없다.
7. 해당 상태에서 T0가 (0,2,0)을 요청→ 자원은 충분히 있지만 불안전 상태를 만들기 때문에 요청을 즉시 들어줄 수 없음

### 제약사항

- 프로세스의 **최대 자원 요구량을 미리** 알아야 한다.
- 할당 가능한 자원의 수가 고정되어야 한다.
- 프로세스들은 서로 독립적이어야 한다.
- 자원을 점유한 상태로 프로세스가 종료되면 안된다.

### 자원 할당 그래프 (Resource-Allocation Graph)

![image](https://github.com/do-sopt-cs-study/CS-Morgan/assets/51692363/4935390c-7aea-4d5a-9d4e-957debcef92b)

![image](https://github.com/do-sopt-cs-study/CS-Morgan/assets/51692363/da58c67e-3fde-4876-9012-248786c78a81)

- [프로세스 → 자원] 간선 : 자원 요구
- [자원 → 프로세스] 간선 : 자원 점유

- 사이클이 형성되면 교착상태 가능성이 있다.

## 교착상태 탐지 (Detection)

- 교착상태 예방, 회피 정책은 성능 저하를 감안하더라도 최악의 경우에도 교착상태가 발생하지 않도록 막는 비관적인 방식.
- 탐지와 회복 정책은 교착상태는 가끔 발생하므로 탐지되었을 때에만 회복하는 낙관적 방식

## 교착상태 회복 (Recovery)

탐지된 이후에 교착상태를 빠져나가는 방법

1. 교착상태에 빠진 프로세스를 모두 종료시킨다.
2. 교착상태에 빠진 프로세스들을 롤백시킨다.
   - 다시 교착상태에 빠질 수 있어서 주의해야 한다.
3. 교착상태에서 벗어날 때까지 해당 프로세스들을 하나씩 종료시킨다,
4. 자원을 선점하도록 하여 교착상태에서 벗어나도록 한다.
   - 교착 상태의 프로세스가 점유하고 있는 자원을 양보한다.
   - 우선순위에 의해 자원을 선점한다.
