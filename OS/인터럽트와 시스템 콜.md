## 인터럽트

컴퓨터가 작업을 수행하던 도중 특수한 상황이 발생하여 작업을 중단하고, 특수한 상황을 먼저 처리한 후 원래의 작업으로 되돌아가 나머지 작업을 계속 수행하는 일련의 과정

인터럽트시 해당 시점의 **레지스터**와 **Program counter**(다음 실행할 명령어의 주소)를 PCB에 저장하고 CPU의 제어를 **인터럽트 서비스 루틴**에 넘긴다.

## 인터럽트 처리 과정

![image](https://github.com/sopt-makers/sopt-backend/assets/51692363/4cd7701d-3351-4c75-b42a-cb3b54720d8d)

1. 메인 프로그램 실행 도중 **인터럽트** 발생
2. 현재 수행 중인 프로그램 중단, 레지스터와 PC를 스택에 저장. 인터럽트 서비스 루틴이 제어를 가져감. → 컨텍스트 스위칭 발생. 돌아올 때도 발생.
3. 인터럽트를 발생시킨 프로그램의 명령어의 주소부터 작업 시작
4. 프로그램의 작업이 끝나면 저장해둔 레지서터와 PC로부터 프로세서에 복구
5. 메인 프로그램의 작업 다시 시작

## 인터럽트가 없다면?

컨트롤러가 특정 작업을 시작해야 할 지 계속 체크 필요 - Polling

### **인터럽트 vs 폴링**

인터럽트는 이벤트를 수행하라는 신호를 받으면 그 즉시 이벤트를 실행!

→ 인터럽트 는 정확한 타이밍, 짧은 반응시간의 장점이 있지만 구현 상의 어려움

→ 폴링은 구현이 쉽다는 장점이 있지만 반응시간이 느리고 자원을 많이 사용

## 시스템 콜

![image](https://github.com/sopt-makers/sopt-backend/assets/51692363/73f40f1b-f747-4c7f-b69b-ffbfa4874877)

사용자 프로그램과 운영 체제 커널 간의 인터페이스를 제공하는 메커니즘.

- 인터페이스 제공: 사용자 프로그램이 운영 체제의 기능을 사용할 수 있도록 인터페이스 제공
  - fork(), read(), write() 등등
- 보안: 사용자 프로그램이 직접 하드웨어에 접근하지 못하도록 막음
- 자원 관리: 시스템 자원을 효율적으로 관리하고 할당.

## 시스템 콜 유형

### 프로세스 관리

프로세스의 생성, 실행, 종료 및 동기화와 같은 작업을 관리

- **fork()**: 새 프로세스를 생성
- **exit()**: 프로세스를 종료
- **wait()**: 자식 프로세스가 종료될 때까지 대기
- **exec()**: 새 프로그램을 프로세스 내에서 실행

### **파일 관리**

파일 생성, 삭제, 읽기, 쓰기, 닫기 등 파일 시스템과 관련된 작업을 수행

- **open()**: 파일을 여는 작업 수행
- **read()**: 파일로부터 데이터를 읽음
- **write()**: 파일에 데이터를 씀
- **close()**: 열린 파일을 닫음.

### **장치 관리**

하드웨어 장치에 대한 접근과 제어를 관리

- **ioctl()**: 장치에 대한 제어 작업을 수행.
- **read()**, **write()**: 장치 파일로부터 읽거나 장치 파일에 쓰는 작업을 수행.

### **정보 유지**

시스템 정보의 설정 및 조회를 관리

- **time()**: 현재 시간을 조회.
- **getpid()**: 현재 프로세스의 고유 식별자를 반환.

### **5. 통신**

프로세스 간 통신(IPC) 및 네트워크 통신을 관리

- **socket()**: 네트워크 통신을 위한 소켓을 생성.
- **send()**, **recv()**: 네트워크를 통해 데이터를 송수신.
